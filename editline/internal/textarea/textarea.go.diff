--- textarea.go.orig	2022-08-26 00:26:34.714932000 +0200
+++ textarea.go	2022-09-06 12:51:29.476143000 +0200
@@ -1,3 +1,9 @@
+// The code below is imported from
+// https://github.com/charmbracelet/bubbles/tree/master/textarea
+// Copyright (c) 2020 Charmbracelet, Inc
+// Licensed under MIT license
+// License at https://github.com/charmbracelet/bubbles/blob/master/LICENSE
+
 package textarea
 
 import (
@@ -46,39 +52,39 @@
 	Paste                   key.Binding
 	WordBackward            key.Binding
 	WordForward             key.Binding
+	ToggleOverwriteMode     key.Binding
 
-	UppercaseWordForward  key.Binding
-	LowercaseWordForward  key.Binding
-	CapitalizeWordForward key.Binding
-
 	TransposeCharacterBackward key.Binding
+	UppercaseWordForward       key.Binding
+	LowercaseWordForward       key.Binding
+	CapitalizeWordForward      key.Binding
 }
 
 // DefaultKeyMap is the default set of key bindings for navigating and acting
 // upon the textarea.
 var DefaultKeyMap = KeyMap{
-	CharacterForward:        key.NewBinding(key.WithKeys("right", "ctrl+f")),
-	CharacterBackward:       key.NewBinding(key.WithKeys("left", "ctrl+b")),
-	WordForward:             key.NewBinding(key.WithKeys("alt+right", "alt+f")),
-	WordBackward:            key.NewBinding(key.WithKeys("alt+left", "alt+b")),
-	LineNext:                key.NewBinding(key.WithKeys("down", "ctrl+n")),
-	LinePrevious:            key.NewBinding(key.WithKeys("up", "ctrl+p")),
-	DeleteWordBackward:      key.NewBinding(key.WithKeys("alt+backspace", "ctrl+w")),
-	DeleteWordForward:       key.NewBinding(key.WithKeys("alt+delete", "alt+d")),
-	DeleteAfterCursor:       key.NewBinding(key.WithKeys("ctrl+k")),
-	DeleteBeforeCursor:      key.NewBinding(key.WithKeys("ctrl+u")),
-	InsertNewline:           key.NewBinding(key.WithKeys("enter", "ctrl+m")),
-	DeleteCharacterBackward: key.NewBinding(key.WithKeys("backspace", "ctrl+h")),
-	DeleteCharacterForward:  key.NewBinding(key.WithKeys("delete", "ctrl+d")),
-	LineStart:               key.NewBinding(key.WithKeys("home", "ctrl+a")),
-	LineEnd:                 key.NewBinding(key.WithKeys("end", "ctrl+e")),
-	Paste:                   key.NewBinding(key.WithKeys("ctrl+v")),
+	CharacterForward:        key.NewBinding(key.WithKeys("right", "ctrl+f"), key.WithHelp("C-f/→", "next char")),
+	CharacterBackward:       key.NewBinding(key.WithKeys("left", "ctrl+b"), key.WithHelp("C-b/←", "prev char")),
+	WordForward:             key.NewBinding(key.WithKeys("alt+right", "alt+f"), key.WithHelp("M-f/M-→", "next word")),
+	WordBackward:            key.NewBinding(key.WithKeys("alt+left", "alt+b"), key.WithHelp("M-b/M-←", "prev word")),
+	LineNext:                key.NewBinding(key.WithKeys("down", "ctrl+n"), key.WithHelp("C-n/↓", "move down")),
+	LinePrevious:            key.NewBinding(key.WithKeys("up", "ctrl+p"), key.WithHelp("C-p/↑", "move up")),
+	DeleteWordBackward:      key.NewBinding(key.WithKeys("alt+backspace", "ctrl+w"), key.WithHelp("C-w/M-bksp", "del prev word")),
+	DeleteWordForward:       key.NewBinding(key.WithKeys("alt+delete", "alt+d"), key.WithHelp("M-d/M-del", "del next word")),
+	DeleteAfterCursor:       key.NewBinding(key.WithKeys("ctrl+k"), key.WithHelp("C-k", "del line end")),
+	DeleteBeforeCursor:      key.NewBinding(key.WithKeys("ctrl+u"), key.WithHelp("C-u", "del line start")),
+	InsertNewline:           key.NewBinding(key.WithKeys("enter", "ctrl+m", "ctrl+j"), key.WithHelp("C-m/⤶", "new line/enter")),
+	DeleteCharacterBackward: key.NewBinding(key.WithKeys("backspace", "ctrl+h"), key.WithHelp("C-h/bksp", "del prev char")),
+	DeleteCharacterForward:  key.NewBinding(key.WithKeys("delete", "ctrl+d"), key.WithHelp("C-d/del", "del next char")),
+	LineStart:               key.NewBinding(key.WithKeys("home", "ctrl+a"), key.WithHelp("C-a/home", "start of line")),
+	LineEnd:                 key.NewBinding(key.WithKeys("end", "ctrl+e"), key.WithHelp("C-e/end", "end of line")),
+	Paste:                   key.NewBinding(key.WithKeys("ctrl+v"), key.WithHelp("C-v", "paste")),
+	ToggleOverwriteMode:     key.NewBinding(key.WithKeys("insert", "alt+o"), key.WithHelp("M-o/ins", "toggle overwrite")),
 
-	CapitalizeWordForward: key.NewBinding(key.WithKeys("alt+c")),
-	LowercaseWordForward:  key.NewBinding(key.WithKeys("alt+l")),
-	UppercaseWordForward:  key.NewBinding(key.WithKeys("alt+u")),
-
-	TransposeCharacterBackward: key.NewBinding(key.WithKeys("ctrl+t")),
+	TransposeCharacterBackward: key.NewBinding(key.WithKeys("ctrl+t"), key.WithHelp("C-t", "transpose char")),
+	CapitalizeWordForward:      key.NewBinding(key.WithKeys("alt+c"), key.WithHelp("M-c", "capitalize word")),
+	LowercaseWordForward:       key.NewBinding(key.WithKeys("alt+l"), key.WithHelp("M-l", "lowercase word")),
+	UppercaseWordForward:       key.NewBinding(key.WithKeys("alt+u"), key.WithHelp("M-u", "uppercase word")),
 }
 
 // LineInfo is a helper for keeping track of line information regarding
@@ -129,12 +135,29 @@
 	Err error
 
 	// General settings.
-	Prompt               string
-	Placeholder          string
-	ShowLineNumbers      bool
+
+	// Prompt is printed at the beginning of each line.
+	//
+	// When changing the value of Prompt after the model has been
+	// initialized, ensure that SetWidth() gets called afterwards.
+	//
+	// See also SetPromptFunc().
+	Prompt string
+
+	// Placeholder is the text displayed when the user
+	// hasn't entered anything yet.
+	Placeholder string
+
+	// ShowLineNumbers, if enabled, causes line numbers to be printed
+	// after the prompt.
+	ShowLineNumbers bool
+
+	// EndOfBufferCharacter is displayed at the end of the input.
 	EndOfBufferCharacter rune
-	KeyMap               KeyMap
 
+	// KeyMap encodes the keybindings recognized by the widget.
+	KeyMap KeyMap
+
 	// Styling. FocusedStyle and BlurredStyle are used to style the textarea in
 	// focused and blurred states.
 	FocusedStyle Style
@@ -152,6 +175,13 @@
 	// accept. If 0 or less, there's no limit.
 	CharLimit int
 
+	// If promptFunc is set, it replaces Prompt as a generator for
+	// prompt strings at the beginning of each line.
+	promptFunc func(line int) string
+
+	// promptWidth is the width of the prompt.
+	promptWidth int
+
 	// width is the maximum number of characters that can be displayed at once.
 	// If 0 or less this setting is ignored.
 	width int
@@ -168,6 +198,9 @@
 	// component. When false, ignore keyboard input and hide the cursor.
 	focus bool
 
+	// overwrite indicates whether overwrite mode is currently enabled.
+	overwrite bool
+
 	// Cursor column.
 	col int
 
@@ -268,7 +301,7 @@
 
 // InsertRune inserts a rune at the cursor position.
 func (m *Model) InsertRune(r rune) {
-	if r == '\n' {
+	if r == '\n' || r == '\r' {
 		m.splitLine(m.row, m.col)
 		return
 	}
@@ -277,6 +310,18 @@
 	m.col++
 }
 
+// overwriteRune overwrites the rune at the cursor position.
+func (m *Model) overwriteRune(r rune) {
+	// If we're at the end of the line, or if the input rune is a
+	// newline, simply insert it.  Otherwise, overwrite.
+	if r == '\n' || r == '\r' || (m.col >= len(m.value[m.row])) {
+		m.InsertRune(r)
+		return
+	}
+	m.value[m.row][m.col] = r
+	m.SetCursor(m.col + 1)
+}
+
 // Value returns the value of the text input.
 func (m Model) Value() string {
 	if m.value == nil {
@@ -681,14 +726,20 @@
 // LineInfo returns the number of characters from the start of the
 // (soft-wrapped) line and the (soft-wrapped) line width.
 func (m Model) LineInfo() LineInfo {
-	grid := wrap(m.value[m.row], m.width)
+	return m.LineInfoAt(m.row, m.col)
+}
 
+// LineInfoAt computes the LineInfo at the specified row/column.
+// The caller is responsible for keeping row/col within bounds.
+func (m Model) LineInfoAt(row, col int) LineInfo {
+	grid := wrap(m.value[row], m.width)
+
 	// Find out which line we are currently on. This can be determined by the
 	// m.col and counting the number of runes that we need to skip.
 	var counter int
 	for i, line := range grid {
 		// We've found the line that we are on
-		if counter+len(line) == m.col && i+1 < len(grid) {
+		if counter+len(line) == col && i+1 < len(grid) {
 			// We wrap around to the next line if we are at the end of the
 			// previous line so that we can be at the very beginning of the row
 			return LineInfo{
@@ -696,16 +747,16 @@
 				ColumnOffset: 0,
 				Height:       len(grid),
 				RowOffset:    i + 1,
-				StartColumn:  m.col,
+				StartColumn:  col,
 				Width:        len(grid[i+1]),
 				CharWidth:    rw.StringWidth(string(line)),
 			}
 		}
 
-		if counter+len(line) >= m.col {
+		if counter+len(line) >= col {
 			return LineInfo{
-				CharOffset:   rw.StringWidth(string(line[:max(0, m.col-counter)])),
-				ColumnOffset: m.col - counter,
+				CharOffset:   rw.StringWidth(string(line[:max(0, col-counter)])),
+				ColumnOffset: col - counter,
 				Height:       len(grid),
 				RowOffset:    i,
 				StartColumn:  counter,
@@ -757,10 +808,26 @@
 	// Account for base style borders and padding.
 	inputWidth -= m.style.Base.GetHorizontalFrameSize()
 
-	inputWidth -= rw.StringWidth(m.Prompt)
+	if m.promptFunc == nil {
+		m.promptWidth = rw.StringWidth(m.Prompt)
+	}
+
+	inputWidth -= m.promptWidth
 	m.width = clamp(inputWidth, minWidth, maxWidth)
 }
 
+// SetPromptFunc supersedes the Prompt field and sets a dynamic prompt
+// instead.
+// If the function returns a prompt that is shorter than the
+// specified promptWidth, it will be padded to the left.
+// If it returns a prompt that is longer, display artifacts
+// may occur; the caller is responsible for computing an adequate
+// promptWidth.
+func (m *Model) SetPromptFunc(promptWidth int, fn func(lineIdx int) string) {
+	m.promptFunc = fn
+	m.promptWidth = promptWidth
+}
+
 // Height returns the current height of the textarea.
 func (m Model) Height() int {
 	return m.height
@@ -772,6 +839,48 @@
 	m.viewport.Height = clamp(h, minHeight, maxHeight)
 }
 
+// InsertNewline inserts a newline character at the cursor.
+func (m *Model) InsertNewline() {
+	if len(m.value) >= maxHeight {
+		return
+	}
+	m.col = clamp(m.col, 0, len(m.value[m.row]))
+	m.splitLine(m.row, m.col)
+}
+
+// DeleteCharacterForward deletes the character at the cursor.
+func (m *Model) DeleteCharacterForward() {
+	if len(m.value[m.row]) > 0 && m.col < len(m.value[m.row]) {
+		m.value[m.row] = append(m.value[m.row][:m.col], m.value[m.row][m.col+1:]...)
+	}
+	if m.col >= len(m.value[m.row]) {
+		m.mergeLineBelow(m.row)
+	}
+}
+
+// DeleteCharactersBackward deletes n characters before the cursor.
+func (m *Model) DeleteCharactersBackward(n int) {
+	for n > 0 {
+		m.col = clamp(m.col, 0, len(m.value[m.row]))
+		if m.col <= 0 {
+			m.mergeLineAbove(m.row)
+			n--
+			continue
+		}
+		if len(m.value[m.row]) > 0 {
+			d := n
+			if d > len(m.value[m.row]) {
+				d = len(m.value[m.row])
+			}
+			m.value[m.row] = append(m.value[m.row][:max(0, m.col-d)], m.value[m.row][m.col:]...)
+			if m.col > 0 {
+				m.SetCursor(m.col - d)
+			}
+			n -= d
+		}
+	}
+}
+
 // Update is the Bubble Tea update loop.
 func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) {
 	if !m.focus {
@@ -806,25 +915,9 @@
 			}
 			m.deleteBeforeCursor()
 		case key.Matches(msg, m.KeyMap.DeleteCharacterBackward):
-			m.col = clamp(m.col, 0, len(m.value[m.row]))
-			if m.col <= 0 {
-				m.mergeLineAbove(m.row)
-				break
-			}
-			if len(m.value[m.row]) > 0 {
-				m.value[m.row] = append(m.value[m.row][:max(0, m.col-1)], m.value[m.row][m.col:]...)
-				if m.col > 0 {
-					m.SetCursor(m.col - 1)
-				}
-			}
+			m.DeleteCharactersBackward(1)
 		case key.Matches(msg, m.KeyMap.DeleteCharacterForward):
-			if len(m.value[m.row]) > 0 && m.col < len(m.value[m.row]) {
-				m.value[m.row] = append(m.value[m.row][:m.col], m.value[m.row][m.col+1:]...)
-			}
-			if m.col >= len(m.value[m.row]) {
-				m.mergeLineBelow(m.row)
-				break
-			}
+			m.DeleteCharacterForward()
 		case key.Matches(msg, m.KeyMap.DeleteWordBackward):
 			if m.col <= 0 {
 				m.mergeLineAbove(m.row)
@@ -839,15 +932,19 @@
 			}
 			m.deleteWordRight()
 		case key.Matches(msg, m.KeyMap.InsertNewline):
-			if len(m.value) >= maxHeight {
-				return m, nil
-			}
-			m.col = clamp(m.col, 0, len(m.value[m.row]))
-			m.splitLine(m.row, m.col)
+			m.InsertNewline()
 		case key.Matches(msg, m.KeyMap.LineEnd):
 			m.CursorEnd()
 		case key.Matches(msg, m.KeyMap.LineStart):
 			m.CursorStart()
+		case key.Matches(msg, m.KeyMap.TransposeCharacterBackward):
+			m.transposeLeft()
+		case key.Matches(msg, m.KeyMap.UppercaseWordForward):
+			m.uppercaseRight()
+		case key.Matches(msg, m.KeyMap.LowercaseWordForward):
+			m.lowercaseRight()
+		case key.Matches(msg, m.KeyMap.CapitalizeWordForward):
+			m.capitalizeRight()
 		case key.Matches(msg, m.KeyMap.CharacterForward):
 			m.characterRight()
 		case key.Matches(msg, m.KeyMap.LineNext):
@@ -862,24 +959,21 @@
 			m.CursorUp()
 		case key.Matches(msg, m.KeyMap.WordBackward):
 			m.wordLeft()
-
-		case key.Matches(msg, m.KeyMap.LowercaseWordForward):
-			m.lowercaseRight()
-		case key.Matches(msg, m.KeyMap.UppercaseWordForward):
-			m.uppercaseRight()
-		case key.Matches(msg, m.KeyMap.CapitalizeWordForward):
-			m.capitalizeRight()
-		case key.Matches(msg, m.KeyMap.TransposeCharacterBackward):
-			m.transposeLeft()
-
+		case key.Matches(msg, m.KeyMap.ToggleOverwriteMode):
+			m.overwrite = !m.overwrite
 		default:
-			if m.CharLimit > 0 && rw.StringWidth(m.Value()) >= m.CharLimit {
-				break
+			if !m.overwrite {
+				if m.CharLimit > 0 && rw.StringWidth(m.Value())+len(msg.Runes) >= m.CharLimit {
+					break
+				}
+				for _, r := range msg.Runes {
+					m.InsertRune(r)
+				}
+			} else {
+				for _, r := range msg.Runes {
+					m.overwriteRune(r)
+				}
 			}
-
-			m.col = min(m.col, len(m.value[m.row]))
-			m.value[m.row] = append(m.value[m.row][:m.col], append(msg.Runes, m.value[m.row][m.col:]...)...)
-			m.SetCursor(m.col + len(msg.Runes))
 		}
 
 	case pasteMsg:
@@ -919,6 +1013,7 @@
 
 	var newLines int
 
+	displayLine := 0
 	for l, line := range m.value {
 		wrappedLines := wrap(line, m.width)
 
@@ -929,7 +1024,10 @@
 		}
 
 		for wl, wrappedLine := range wrappedLines {
-			s.WriteString(style.Render(m.style.Prompt.Render(m.Prompt)))
+			prompt := m.getPromptString(displayLine)
+			prompt = m.style.Prompt.Render(prompt)
+			s.WriteString(style.Render(prompt))
+			displayLine++
 
 			if m.ShowLineNumbers {
 				if wl == 0 {
@@ -978,7 +1076,10 @@
 	// Always show at least `m.Height` lines at all times.
 	// To do this we can simply pad out a few extra new lines in the view.
 	for i := 0; i < m.height; i++ {
-		s.WriteString(m.style.Prompt.Render(m.Prompt))
+		prompt := m.getPromptString(displayLine)
+		prompt = m.style.Prompt.Render(prompt)
+		s.WriteString(prompt)
+		displayLine++
 
 		if m.ShowLineNumbers {
 			lineNumber := m.style.EndOfBuffer.Render((fmt.Sprintf(m.lineNumberFormat, string(m.EndOfBufferCharacter))))
@@ -991,6 +1092,19 @@
 	return m.style.Base.Render(m.viewport.View())
 }
 
+func (m Model) getPromptString(displayLine int) (prompt string) {
+	prompt = m.Prompt
+	if m.promptFunc == nil {
+		return prompt
+	}
+	prompt = m.promptFunc(displayLine)
+	pl := rw.StringWidth(prompt)
+	if pl < m.promptWidth {
+		prompt = fmt.Sprintf("%*s%s", m.promptWidth-pl, "", prompt)
+	}
+	return prompt
+}
+
 // placeholderView returns the prompt and placeholder view, if any.
 func (m Model) placeholderView() string {
 	var (
@@ -999,7 +1113,8 @@
 		style = m.style.Placeholder.Inline(true)
 	)
 
-	prompt := m.style.Prompt.Render(m.Prompt)
+	prompt := m.getPromptString(0)
+	prompt = m.style.Prompt.Render(prompt)
 	s.WriteString(m.style.CursorLine.Render(prompt))
 
 	if m.ShowLineNumbers {
@@ -1016,6 +1131,8 @@
 	// The rest of the new lines
 	for i := 1; i < m.height; i++ {
 		s.WriteRune('\n')
+		prompt := m.getPromptString(i)
+		prompt = m.style.Prompt.Render(prompt)
 		s.WriteString(prompt)
 
 		if m.ShowLineNumbers {
