--- textarea.go.orig	2022-08-14 09:32:31.052817000 +0200
+++ textarea.go	2022-08-14 20:34:28.983090000 +0200
@@ -1,3 +1,9 @@
+// The code below is imported from
+// https://github.com/charmbracelet/bubbles/tree/master/textarea
+// Copyright (c) 2020 Charmbracelet, Inc
+// Licensed under MIT license
+// License at https://github.com/charmbracelet/bubbles/blob/master/LICENSE
+
 package textarea
 
 import (
@@ -46,6 +52,11 @@
 	Paste                   key.Binding
 	WordBackward            key.Binding
 	WordForward             key.Binding
+
+	TransposeCharacterBackward key.Binding
+	UppercaseWordForward       key.Binding
+	LowercaseWordForward       key.Binding
+	CapitalizeWordForward      key.Binding
 }
 
 // DefaultKeyMap is the default set of key bindings for navigating and acting
@@ -67,6 +78,11 @@
 	LineStart:               key.NewBinding(key.WithKeys("home", "ctrl+a")),
 	LineEnd:                 key.NewBinding(key.WithKeys("end", "ctrl+e")),
 	Paste:                   key.NewBinding(key.WithKeys("ctrl+v")),
+
+	TransposeCharacterBackward: key.NewBinding(key.WithKeys("ctrl+t")),
+	CapitalizeWordForward:      key.NewBinding(key.WithKeys("alt+c")),
+	LowercaseWordForward:       key.NewBinding(key.WithKeys("alt+l")),
+	UppercaseWordForward:       key.NewBinding(key.WithKeys("alt+u")),
 }
 
 // LineInfo is a helper for keeping track of line information regarding
@@ -109,6 +125,7 @@
 	LineNumber       lipgloss.Style
 	Placeholder      lipgloss.Style
 	Prompt           lipgloss.Style
+	NextPrompt       lipgloss.Style
 	Text             lipgloss.Style
 }
 
@@ -123,6 +140,10 @@
 	EndOfBufferCharacter rune
 	KeyMap               KeyMap
 
+	// NextPrompt, if set, is used for all lines
+	// except the first.
+	NextPrompt string
+
 	// Styling. FocusedStyle and BlurredStyle are used to style the textarea in
 	// focused and blurred states.
 	FocusedStyle Style
@@ -193,7 +214,7 @@
 		Cursor:               cur,
 		KeyMap:               DefaultKeyMap,
 
-		value:            make([][]rune, minHeight, maxWidth),
+		value:            make([][]rune, minHeight, maxHeight),
 		focus:            false,
 		col:              0,
 		row:              0,
@@ -219,6 +240,7 @@
 		LineNumber:       lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "249", Dark: "7"}),
 		Placeholder:      lipgloss.NewStyle().Foreground(lipgloss.Color("240")),
 		Prompt:           lipgloss.NewStyle().Foreground(lipgloss.Color("7")),
+		NextPrompt:       lipgloss.NewStyle().Foreground(lipgloss.Color("7")),
 		Text:             lipgloss.NewStyle(),
 	}
 	blurred := Style{
@@ -229,6 +251,7 @@
 		LineNumber:       lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "249", Dark: "7"}),
 		Placeholder:      lipgloss.NewStyle().Foreground(lipgloss.Color("240")),
 		Prompt:           lipgloss.NewStyle().Foreground(lipgloss.Color("7")),
+		NextPrompt:       lipgloss.NewStyle().Foreground(lipgloss.Color("7")),
 		Text:             lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "245", Dark: "7"}),
 	}
 
@@ -256,7 +279,7 @@
 
 // InsertRune inserts a rune at the cursor position.
 func (m *Model) InsertRune(r rune) {
-	if r == '\n' {
+	if r == '\n' || r == '\r' {
 		m.splitLine(m.row, m.col)
 		return
 	}
@@ -271,13 +294,13 @@
 		return ""
 	}
 
-	var v string
+	var v strings.Builder
 	for _, l := range m.value {
-		v += string(l)
-		v += "\n"
+		v.WriteString(string(l))
+		v.WriteByte('\n')
 	}
 
-	return strings.TrimSuffix(v, "\n")
+	return strings.TrimSuffix(v.String(), "\n")
 }
 
 // Length returns the number of characters currently in the text input.
@@ -409,7 +432,7 @@
 
 // Reset sets the input to its default state with no input.
 func (m *Model) Reset() {
-	m.value = make([][]rune, minHeight, maxWidth)
+	m.value = make([][]rune, minHeight, maxHeight)
 	m.col = 0
 	m.row = 0
 	m.viewport.GotoTop()
@@ -473,6 +496,24 @@
 	m.SetCursor(len(m.value[m.row]))
 }
 
+// transposeLeft exchanges the runes at the cursor and immediately
+// before. No-op if the cursor is at the beginning of the line.  If
+// the cursor is not at the end of the line yet, moves the cursor to
+// the right.
+func (m *Model) transposeLeft() {
+	if m.col == 0 || len(m.value[m.row]) < 2 {
+		return
+	}
+	if m.col >= len(m.value[m.row]) {
+		m.SetCursor(m.col - 1)
+	}
+	m.value[m.row][m.col-1], m.value[m.row][m.col] =
+		m.value[m.row][m.col], m.value[m.row][m.col-1]
+	if m.col < len(m.value[m.row]) {
+		m.SetCursor(m.col + 1)
+	}
+}
+
 // deleteWordLeft deletes the word left to the cursor. Returns whether or not
 // the cursor blink should be reset.
 func (m *Model) deleteWordLeft() {
@@ -547,31 +588,50 @@
 	m.SetCursor(oldCol)
 }
 
+// characterRight moves the cursor one character to the right.
+func (m *Model) characterRight() {
+	if m.col < len(m.value[m.row]) {
+		m.SetCursor(m.col + 1)
+	} else {
+		if m.row < len(m.value)-1 {
+			m.row++
+			m.CursorStart()
+		}
+	}
+}
+
+// characterLeft moves the cursor one character to the left.
+// If insideLine is set, the cursor is moved to the last
+// character in the previous line, instead of one past that.
+func (m *Model) characterLeft(insideLine bool) {
+	if m.col == 0 && m.row != 0 {
+		m.row--
+		m.CursorEnd()
+		if !insideLine {
+			return
+		}
+	}
+	if m.col > 0 {
+		m.SetCursor(m.col - 1)
+	}
+}
+
 // wordLeft moves the cursor one word to the left. Returns whether or not the
 // cursor blink should be reset. If input is masked, move input to the start
 // so as not to reveal word breaks in the masked input.
 func (m *Model) wordLeft() {
-	if m.col == 0 || len(m.value[m.row]) == 0 {
-		return
-	}
-
-	i := m.col - 1
-	for i >= 0 {
-		if unicode.IsSpace(m.value[m.row][min(i, len(m.value[m.row])-1)]) {
-			m.SetCursor(m.col - 1)
-			i--
-		} else {
+	for {
+		m.characterLeft(true /* insideLine */)
+		if m.col < len(m.value[m.row]) && !unicode.IsSpace(m.value[m.row][m.col]) {
 			break
 		}
 	}
 
-	for i >= 0 {
-		if !unicode.IsSpace(m.value[m.row][min(i, len(m.value[m.row])-1)]) {
-			m.SetCursor(m.col - 1)
-			i--
-		} else {
+	for m.col > 0 {
+		if unicode.IsSpace(m.value[m.row][m.col-1]) {
 			break
 		}
+		m.SetCursor(m.col - 1)
 	}
 }
 
@@ -579,41 +639,69 @@
 // cursor blink should be reset. If the input is masked, move input to the end
 // so as not to reveal word breaks in the masked input.
 func (m *Model) wordRight() {
-	if m.col >= len(m.value[m.row]) || len(m.value[m.row]) == 0 {
-		return
-	}
+	m.doWordRight(func(bool, int) { /* nothing */ })
+}
 
-	i := m.col
-	for i < len(m.value[m.row]) {
-		if unicode.IsSpace(m.value[m.row][i]) {
-			m.SetCursor(m.col + 1)
-			i++
-		} else {
+func (m *Model) doWordRight(fn func(firstChar bool, pos int)) {
+	// Skip spaces forward.
+	for {
+		if m.col < len(m.value[m.row]) && !unicode.IsSpace(m.value[m.row][m.col]) {
 			break
 		}
+		m.characterRight()
 	}
 
-	for i < len(m.value[m.row]) {
-		if !unicode.IsSpace(m.value[m.row][i]) {
-			m.SetCursor(m.col + 1)
-			i++
-		} else {
+	firstChar := true
+	for m.col < len(m.value[m.row]) {
+		if unicode.IsSpace(m.value[m.row][m.col]) {
 			break
 		}
+		fn(firstChar, m.col)
+		firstChar = false
+		m.SetCursor(m.col + 1)
 	}
 }
 
+// uppercaseRight changes the word to the right to uppercase.
+func (m *Model) uppercaseRight() {
+	m.doWordRight(func(_ bool, i int) {
+		m.value[m.row][i] = unicode.ToUpper(m.value[m.row][i])
+	})
+}
+
+// lowercaseRight changes the word to the right to lowercase.
+func (m *Model) lowercaseRight() {
+	m.doWordRight(func(_ bool, i int) {
+		m.value[m.row][i] = unicode.ToLower(m.value[m.row][i])
+	})
+}
+
+// capitalizeRight changes the word to the right to title case.
+func (m *Model) capitalizeRight() {
+	m.doWordRight(func(firstChar bool, i int) {
+		if firstChar {
+			m.value[m.row][i] = unicode.ToTitle(m.value[m.row][i])
+		}
+	})
+}
+
 // LineInfo returns the number of characters from the start of the
 // (soft-wrapped) line and the (soft-wrapped) line width.
 func (m Model) LineInfo() LineInfo {
-	grid := wrap(m.value[m.row], m.width)
+	return m.LineInfoAt(m.row, m.col)
+}
 
+// LineInfoAt computes the LineInfo at the specified row/column.
+// The caller is responsible for keeping row/col within bounds.
+func (m Model) LineInfoAt(row, col int) LineInfo {
+	grid := wrap(m.value[row], m.width)
+
 	// Find out which line we are currently on. This can be determined by the
 	// m.col and counting the number of runes that we need to skip.
 	var counter int
 	for i, line := range grid {
 		// We've found the line that we are on
-		if counter+len(line) == m.col && i+1 < len(grid) {
+		if counter+len(line) == col && i+1 < len(grid) {
 			// We wrap around to the next line if we are at the end of the
 			// previous line so that we can be at the very beginning of the row
 			return LineInfo{
@@ -621,16 +709,16 @@
 				ColumnOffset: 0,
 				Height:       len(grid),
 				RowOffset:    i + 1,
-				StartColumn:  m.col,
+				StartColumn:  col,
 				Width:        len(grid[i+1]),
 				CharWidth:    rw.StringWidth(string(line)),
 			}
 		}
 
-		if counter+len(line) >= m.col {
+		if counter+len(line) >= col {
 			return LineInfo{
-				CharOffset:   rw.StringWidth(string(line[:max(0, m.col-counter)])),
-				ColumnOffset: m.col - counter,
+				CharOffset:   rw.StringWidth(string(line[:max(0, col-counter)])),
+				ColumnOffset: col - counter,
 				Height:       len(grid),
 				RowOffset:    i,
 				StartColumn:  counter,
@@ -682,7 +770,7 @@
 	// Account for base style borders and padding.
 	inputWidth -= m.style.Base.GetHorizontalFrameSize()
 
-	inputWidth -= rw.StringWidth(m.Prompt)
+	inputWidth -= max(rw.StringWidth(m.Prompt), rw.StringWidth(m.NextPrompt))
 	m.width = clamp(inputWidth, minWidth, maxWidth)
 }
 
@@ -697,6 +785,25 @@
 	m.viewport.Height = clamp(h, minHeight, maxHeight)
 }
 
+// InsertNewline inserts a newline character at the cursor.
+func (m *Model) InsertNewline() {
+	if len(m.value) >= maxHeight {
+		return
+	}
+	m.col = clamp(m.col, 0, len(m.value[m.row]))
+	m.splitLine(m.row, m.col)
+}
+
+// DeleteCharacterForward deletes the character at the cursor.
+func (m *Model) DeleteCharacterForward() {
+	if len(m.value[m.row]) > 0 && m.col < len(m.value[m.row]) {
+		m.value[m.row] = append(m.value[m.row][:m.col], m.value[m.row][m.col+1:]...)
+	}
+	if m.col >= len(m.value[m.row]) {
+		m.mergeLineBelow(m.row)
+	}
+}
+
 // Update is the Bubble Tea update loop.
 func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) {
 	if !m.focus {
@@ -743,13 +850,7 @@
 				}
 			}
 		case key.Matches(msg, m.KeyMap.DeleteCharacterForward):
-			if len(m.value[m.row]) > 0 && m.col < len(m.value[m.row]) {
-				m.value[m.row] = append(m.value[m.row][:m.col], m.value[m.row][m.col+1:]...)
-			}
-			if m.col >= len(m.value[m.row]) {
-				m.mergeLineBelow(m.row)
-				break
-			}
+			m.DeleteCharacterForward()
 		case key.Matches(msg, m.KeyMap.DeleteWordBackward):
 			if m.col <= 0 {
 				m.mergeLineAbove(m.row)
@@ -764,24 +865,21 @@
 			}
 			m.deleteWordRight()
 		case key.Matches(msg, m.KeyMap.InsertNewline):
-			if len(m.value) >= maxHeight {
-				return m, nil
-			}
-			m.col = clamp(m.col, 0, len(m.value[m.row]))
-			m.splitLine(m.row, m.col)
+			m.InsertNewline()
 		case key.Matches(msg, m.KeyMap.LineEnd):
 			m.CursorEnd()
 		case key.Matches(msg, m.KeyMap.LineStart):
 			m.CursorStart()
+		case key.Matches(msg, m.KeyMap.TransposeCharacterBackward):
+			m.transposeLeft()
+		case key.Matches(msg, m.KeyMap.UppercaseWordForward):
+			m.uppercaseRight()
+		case key.Matches(msg, m.KeyMap.LowercaseWordForward):
+			m.lowercaseRight()
+		case key.Matches(msg, m.KeyMap.CapitalizeWordForward):
+			m.capitalizeRight()
 		case key.Matches(msg, m.KeyMap.CharacterForward):
-			if m.col < len(m.value[m.row]) {
-				m.SetCursor(m.col + 1)
-			} else {
-				if m.row < len(m.value)-1 {
-					m.row++
-					m.CursorStart()
-				}
-			}
+			m.characterRight()
 		case key.Matches(msg, m.KeyMap.LineNext):
 			m.CursorDown()
 		case key.Matches(msg, m.KeyMap.WordForward):
@@ -789,26 +887,18 @@
 		case key.Matches(msg, m.KeyMap.Paste):
 			return m, Paste
 		case key.Matches(msg, m.KeyMap.CharacterBackward):
-			if m.col == 0 && m.row != 0 {
-				m.row--
-				m.CursorEnd()
-				break
-			}
-			if m.col > 0 {
-				m.SetCursor(m.col - 1)
-			}
+			m.characterLeft(false /* insideLine */)
 		case key.Matches(msg, m.KeyMap.LinePrevious):
 			m.CursorUp()
 		case key.Matches(msg, m.KeyMap.WordBackward):
 			m.wordLeft()
 		default:
-			if m.CharLimit > 0 && rw.StringWidth(m.Value()) >= m.CharLimit {
+			if m.CharLimit > 0 && rw.StringWidth(m.Value())+len(msg.Runes) >= m.CharLimit {
 				break
 			}
-
-			m.col = min(m.col, len(m.value[m.row]))
-			m.value[m.row] = append(m.value[m.row][:m.col], append(msg.Runes, m.value[m.row][m.col:]...)...)
-			m.SetCursor(m.col + len(msg.Runes))
+			for _, r := range msg.Runes {
+				m.InsertRune(r)
+			}
 		}
 
 	case pasteMsg:
@@ -848,6 +938,11 @@
 
 	var newLines int
 
+	prompt, nextPrompt := m.getPromptStrings()
+	prompt = m.style.Prompt.Render(prompt)
+	nextPrompt = m.style.NextPrompt.Render(nextPrompt)
+
+	firstDisplayLine := true
 	for l, line := range m.value {
 		wrappedLines := wrap(line, m.width)
 
@@ -858,7 +953,12 @@
 		}
 
 		for wl, wrappedLine := range wrappedLines {
-			s.WriteString(style.Render(m.style.Prompt.Render(m.Prompt)))
+			selectedPrompt := nextPrompt
+			if firstDisplayLine {
+				selectedPrompt = prompt
+				firstDisplayLine = false
+			}
+			s.WriteString(style.Render(selectedPrompt))
 
 			if m.ShowLineNumbers {
 				if wl == 0 {
@@ -907,7 +1007,7 @@
 	// Always show at least `m.Height` lines at all times.
 	// To do this we can simply pad out a few extra new lines in the view.
 	for i := 0; i < m.height; i++ {
-		s.WriteString(m.style.Prompt.Render(m.Prompt))
+		s.WriteString(nextPrompt)
 
 		if m.ShowLineNumbers {
 			lineNumber := m.style.EndOfBuffer.Render((fmt.Sprintf(m.lineNumberFormat, string(m.EndOfBufferCharacter))))
@@ -920,6 +1020,22 @@
 	return m.style.Base.Render(m.viewport.View())
 }
 
+func (m Model) getPromptStrings() (prompt, nextPrompt string) {
+	prompt = m.Prompt
+	nextPrompt = m.NextPrompt
+	if nextPrompt == "" {
+		return prompt, prompt
+	}
+	pl := rw.StringWidth(prompt)
+	npl := rw.StringWidth(nextPrompt)
+	if pl > npl {
+		nextPrompt = fmt.Sprintf("%*s", pl-npl, "") + nextPrompt
+	} else if npl > pl {
+		prompt = fmt.Sprintf("%*s", npl-pl, "") + prompt
+	}
+	return prompt, nextPrompt
+}
+
 // placeholderView returns the prompt and placeholder view, if any.
 func (m Model) placeholderView() string {
 	var (
@@ -928,7 +1044,9 @@
 		style = m.style.Placeholder.Inline(true)
 	)
 
-	prompt := m.style.Prompt.Render(m.Prompt)
+	prompt, nextPrompt := m.getPromptStrings()
+
+	prompt = m.style.Prompt.Render(prompt)
 	s.WriteString(m.style.CursorLine.Render(prompt))
 
 	if m.ShowLineNumbers {
@@ -943,9 +1061,10 @@
 	s.WriteString(m.style.CursorLine.Render(style.Render(p[1:] + strings.Repeat(" ", max(0, m.width-rw.StringWidth(p))))))
 
 	// The rest of the new lines
+	nextPrompt = m.style.NextPrompt.Render(nextPrompt)
 	for i := 1; i < m.height; i++ {
 		s.WriteRune('\n')
-		s.WriteString(prompt)
+		s.WriteString(nextPrompt)
 
 		if m.ShowLineNumbers {
 			eob := m.style.EndOfBuffer.Render((fmt.Sprintf(m.lineNumberFormat, string(m.EndOfBufferCharacter))))
