--- textarea.go.orig	2022-08-14 09:32:31.052817000 +0200
+++ textarea.go	2022-08-14 10:18:37.279849000 +0200
@@ -1,3 +1,9 @@
+// The code below is imported from
+// https://github.com/charmbracelet/bubbles/tree/master/textarea
+// Copyright (c) 2020 Charmbracelet, Inc
+// Licensed under MIT license
+// License at https://github.com/charmbracelet/bubbles/blob/master/LICENSE
+
 package textarea
 
 import (
@@ -46,6 +52,11 @@
 	Paste                   key.Binding
 	WordBackward            key.Binding
 	WordForward             key.Binding
+
+	TransposeCharacterBackward key.Binding
+	UppercaseWordForward       key.Binding
+	LowercaseWordForward       key.Binding
+	CapitalizeWordForward      key.Binding
 }
 
 // DefaultKeyMap is the default set of key bindings for navigating and acting
@@ -67,6 +78,11 @@
 	LineStart:               key.NewBinding(key.WithKeys("home", "ctrl+a")),
 	LineEnd:                 key.NewBinding(key.WithKeys("end", "ctrl+e")),
 	Paste:                   key.NewBinding(key.WithKeys("ctrl+v")),
+
+	TransposeCharacterBackward: key.NewBinding(key.WithKeys("ctrl+t")),
+	CapitalizeWordForward:      key.NewBinding(key.WithKeys("alt+c")),
+	LowercaseWordForward:       key.NewBinding(key.WithKeys("alt+l")),
+	UppercaseWordForward:       key.NewBinding(key.WithKeys("alt+u")),
 }
 
 // LineInfo is a helper for keeping track of line information regarding
@@ -473,6 +489,24 @@
 	m.SetCursor(len(m.value[m.row]))
 }
 
+// transposeLeft exchanges the runes at the cursor and immediately
+// before. No-op if the cursor is at the beginning of the line.  If
+// the cursor is not at the end of the line yet, moves the cursor to
+// the right.
+func (m *Model) transposeLeft() {
+	if m.col == 0 || len(m.value[m.row]) < 2 {
+		return
+	}
+	if m.col >= len(m.value[m.row]) {
+		m.SetCursor(m.col - 1)
+	}
+	m.value[m.row][m.col-1], m.value[m.row][m.col] =
+		m.value[m.row][m.col], m.value[m.row][m.col-1]
+	if m.col < len(m.value[m.row]) {
+		m.SetCursor(m.col + 1)
+	}
+}
+
 // deleteWordLeft deletes the word left to the cursor. Returns whether or not
 // the cursor blink should be reset.
 func (m *Model) deleteWordLeft() {
@@ -547,31 +581,50 @@
 	m.SetCursor(oldCol)
 }
 
+// characterRight moves the cursor one character to the right.
+func (m *Model) characterRight() {
+	if m.col < len(m.value[m.row]) {
+		m.SetCursor(m.col + 1)
+	} else {
+		if m.row < len(m.value)-1 {
+			m.row++
+			m.CursorStart()
+		}
+	}
+}
+
+// characterLeft moves the cursor one character to the left.
+// If insideLine is set, the cursor is moved to the last
+// character in the previous line, instead of one past that.
+func (m *Model) characterLeft(insideLine bool) {
+	if m.col == 0 && m.row != 0 {
+		m.row--
+		m.CursorEnd()
+		if !insideLine {
+			return
+		}
+	}
+	if m.col > 0 {
+		m.SetCursor(m.col - 1)
+	}
+}
+
 // wordLeft moves the cursor one word to the left. Returns whether or not the
 // cursor blink should be reset. If input is masked, move input to the start
 // so as not to reveal word breaks in the masked input.
 func (m *Model) wordLeft() {
-	if m.col == 0 || len(m.value[m.row]) == 0 {
-		return
-	}
-
-	i := m.col - 1
-	for i >= 0 {
-		if unicode.IsSpace(m.value[m.row][min(i, len(m.value[m.row])-1)]) {
-			m.SetCursor(m.col - 1)
-			i--
-		} else {
+	for {
+		m.characterLeft(true /* insideLine */)
+		if m.col < len(m.value[m.row]) && !unicode.IsSpace(m.value[m.row][m.col]) {
 			break
 		}
 	}
 
-	for i >= 0 {
-		if !unicode.IsSpace(m.value[m.row][min(i, len(m.value[m.row])-1)]) {
-			m.SetCursor(m.col - 1)
-			i--
-		} else {
+	for m.col > 0 {
+		if unicode.IsSpace(m.value[m.row][m.col-1]) {
 			break
 		}
+		m.SetCursor(m.col - 1)
 	}
 }
 
@@ -579,41 +632,69 @@
 // cursor blink should be reset. If the input is masked, move input to the end
 // so as not to reveal word breaks in the masked input.
 func (m *Model) wordRight() {
-	if m.col >= len(m.value[m.row]) || len(m.value[m.row]) == 0 {
-		return
-	}
+	m.doWordRight(func(bool, int) { /* nothing */ })
+}
 
-	i := m.col
-	for i < len(m.value[m.row]) {
-		if unicode.IsSpace(m.value[m.row][i]) {
-			m.SetCursor(m.col + 1)
-			i++
-		} else {
+func (m *Model) doWordRight(fn func(firstChar bool, pos int)) {
+	// Skip spaces forward.
+	for {
+		if m.col < len(m.value[m.row]) && !unicode.IsSpace(m.value[m.row][m.col]) {
 			break
 		}
+		m.characterRight()
 	}
 
-	for i < len(m.value[m.row]) {
-		if !unicode.IsSpace(m.value[m.row][i]) {
-			m.SetCursor(m.col + 1)
-			i++
-		} else {
+	firstChar := true
+	for m.col < len(m.value[m.row]) {
+		if unicode.IsSpace(m.value[m.row][m.col]) {
 			break
 		}
+		fn(firstChar, m.col)
+		firstChar = false
+		m.SetCursor(m.col + 1)
 	}
 }
 
+// uppecaseRight changes the word to the right to uppercase.
+func (m *Model) uppercaseRight() {
+	m.doWordRight(func(_ bool, i int) {
+		m.value[m.row][i] = unicode.ToUpper(m.value[m.row][i])
+	})
+}
+
+// lowercaseRight changes the word to the right to lowercase.
+func (m *Model) lowercaseRight() {
+	m.doWordRight(func(_ bool, i int) {
+		m.value[m.row][i] = unicode.ToLower(m.value[m.row][i])
+	})
+}
+
+// capitalizeRight changes the word to the right to title case.
+func (m *Model) capitalizeRight() {
+	m.doWordRight(func(firstChar bool, i int) {
+		if firstChar {
+			m.value[m.row][i] = unicode.ToTitle(m.value[m.row][i])
+		}
+	})
+}
+
 // LineInfo returns the number of characters from the start of the
 // (soft-wrapped) line and the (soft-wrapped) line width.
 func (m Model) LineInfo() LineInfo {
-	grid := wrap(m.value[m.row], m.width)
+	return m.LineInfoAt(m.row, m.col)
+}
 
+// LineInfoAt computes the LineInfo at the specified row/column.
+// The caller is responsible for keeping row/col within bounds.
+func (m Model) LineInfoAt(row, col int) LineInfo {
+	grid := wrap(m.value[row], m.width)
+
 	// Find out which line we are currently on. This can be determined by the
 	// m.col and counting the number of runes that we need to skip.
 	var counter int
 	for i, line := range grid {
 		// We've found the line that we are on
-		if counter+len(line) == m.col && i+1 < len(grid) {
+		if counter+len(line) == col && i+1 < len(grid) {
 			// We wrap around to the next line if we are at the end of the
 			// previous line so that we can be at the very beginning of the row
 			return LineInfo{
@@ -621,16 +702,16 @@
 				ColumnOffset: 0,
 				Height:       len(grid),
 				RowOffset:    i + 1,
-				StartColumn:  m.col,
+				StartColumn:  col,
 				Width:        len(grid[i+1]),
 				CharWidth:    rw.StringWidth(string(line)),
 			}
 		}
 
-		if counter+len(line) >= m.col {
+		if counter+len(line) >= col {
 			return LineInfo{
-				CharOffset:   rw.StringWidth(string(line[:max(0, m.col-counter)])),
-				ColumnOffset: m.col - counter,
+				CharOffset:   rw.StringWidth(string(line[:max(0, col-counter)])),
+				ColumnOffset: col - counter,
 				Height:       len(grid),
 				RowOffset:    i,
 				StartColumn:  counter,
@@ -773,15 +854,16 @@
 			m.CursorEnd()
 		case key.Matches(msg, m.KeyMap.LineStart):
 			m.CursorStart()
+		case key.Matches(msg, m.KeyMap.TransposeCharacterBackward):
+			m.transposeLeft()
+		case key.Matches(msg, m.KeyMap.UppercaseWordForward):
+			m.uppercaseRight()
+		case key.Matches(msg, m.KeyMap.LowercaseWordForward):
+			m.lowercaseRight()
+		case key.Matches(msg, m.KeyMap.CapitalizeWordForward):
+			m.capitalizeRight()
 		case key.Matches(msg, m.KeyMap.CharacterForward):
-			if m.col < len(m.value[m.row]) {
-				m.SetCursor(m.col + 1)
-			} else {
-				if m.row < len(m.value)-1 {
-					m.row++
-					m.CursorStart()
-				}
-			}
+			m.characterRight()
 		case key.Matches(msg, m.KeyMap.LineNext):
 			m.CursorDown()
 		case key.Matches(msg, m.KeyMap.WordForward):
@@ -789,14 +871,7 @@
 		case key.Matches(msg, m.KeyMap.Paste):
 			return m, Paste
 		case key.Matches(msg, m.KeyMap.CharacterBackward):
-			if m.col == 0 && m.row != 0 {
-				m.row--
-				m.CursorEnd()
-				break
-			}
-			if m.col > 0 {
-				m.SetCursor(m.col - 1)
-			}
+			m.characterLeft(false /* insideLine */)
 		case key.Matches(msg, m.KeyMap.LinePrevious):
 			m.CursorUp()
 		case key.Matches(msg, m.KeyMap.WordBackward):
